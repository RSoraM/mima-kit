import { KitError } from '../../core/utils'
import { createCipher } from '../../core/cipher'

// * Constants

const SBox = new Uint8Array([0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16])
const InvSBox = new Uint8Array([0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D])
const ROUND = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]

// * Functions

function GFMultiply(a: number, b: number): number {
  let p = 0
  if (b === 1) {
    return a
  }
  for (let i = 0; i < 8; i++) {
    if (b & 1) {
      p ^= a
    }
    const carry = a & 0x80
    a <<= 1
    if (carry) {
      a ^= 0x1B // 0x1B 是不可约多项式 x^8 + x^4 + x^3 + x + 1 的低 8 位
    }
    b >>= 1
  }
  return p & 0xFF
}

function KeyExpansion(K: Uint8Array, Nr: 10 | 12 | 14) {
  const Nk = K.byteLength >> 2
  const W = new Uint8Array((Nr + 1) << 4)
  W.set(K)
  let current = 0
  for (let i = Nk; i < (Nr + 1) << 2; i++) {
    const i_1 = (i - 1) << 2
    const temp = W.slice(i_1, i_1 + 4)
    if (i % Nk === 0) {
      const t0 = temp[0]
      temp[0] = SBox[temp[1]] ^ ROUND[current]
      temp[1] = SBox[temp[2]]
      temp[2] = SBox[temp[3]]
      temp[3] = SBox[t0]

      current++
    }
    else if (Nk > 6 && i % Nk === 4) {
      temp[0] = SBox[temp[0]]
      temp[1] = SBox[temp[1]]
      temp[2] = SBox[temp[2]]
      temp[3] = SBox[temp[3]]
    }
    const i_Nk = (i - Nk) << 2
    const Wi_NK = W.subarray(i_Nk, i_Nk + 4)
    for (let j = 0; j < 4; j++) {
      temp[j] ^= Wi_NK[j]
    }
    W.set(temp, i << 2)
  }
  return W
}

// * AES Algorithm

function Cipher(M: Uint8Array, W: Uint8Array, Nr: 10 | 12 | 14) {
  if (M.byteLength !== 16) {
    throw new KitError(`Message length must be 16 bytes`)
  }
  const S = M.slice(0)

  const AddRoundKey = (W: Uint8Array) => {
    for (let i = 0; i < S.byteLength; i++) {
      S[i] ^= W[i]
    }
  }
  const SubBytes = () => {
    for (let i = 0; i < S.byteLength; i++) {
      S[i] = SBox[S[i]]
    }
  }
  const ShiftRows = () => {
    const S1 = S[1]
    S[1] = S[5]
    S[5] = S[9]
    S[9] = S[13]
    S[13] = S1

    const S2 = S[2]
    const S6 = S[6]
    S[2] = S[10]
    S[6] = S[14]
    S[10] = S2
    S[14] = S6

    const S15 = S[15]
    S[15] = S[11]
    S[11] = S[7]
    S[7] = S[3]
    S[3] = S15
  }
  const MixColumn = () => {
    for (let i = 0; i < 4; i++) {
      const s0 = S[(i << 2)]
      const s1 = S[(i << 2) + 1]
      const s2 = S[(i << 2) + 2]
      const s3 = S[(i << 2) + 3]

      const t0 = GFMultiply(s0, 0x02) ^ GFMultiply(s1, 0x03) ^ GFMultiply(s2, 0x01) ^ GFMultiply(s3, 0x01)
      const t1 = GFMultiply(s0, 0x01) ^ GFMultiply(s1, 0x02) ^ GFMultiply(s2, 0x03) ^ GFMultiply(s3, 0x01)
      const t2 = GFMultiply(s0, 0x01) ^ GFMultiply(s1, 0x01) ^ GFMultiply(s2, 0x02) ^ GFMultiply(s3, 0x03)
      const t3 = GFMultiply(s0, 0x03) ^ GFMultiply(s1, 0x01) ^ GFMultiply(s2, 0x01) ^ GFMultiply(s3, 0x02)

      S[(i << 2)] = t0
      S[(i << 2) + 1] = t1
      S[(i << 2) + 2] = t2
      S[(i << 2) + 3] = t3
    }
  }

  AddRoundKey(W.subarray(0, 16))
  for (let i = 1; i < Nr; i++) {
    SubBytes()
    ShiftRows()
    MixColumn()
    AddRoundKey(W.subarray(i << 4, (i + 1) << 4))
  }
  SubBytes()
  ShiftRows()
  AddRoundKey(W.subarray(W.length - 16, W.length))

  return S
}

function InvCipher(M: Uint8Array, W: Uint8Array, Nr: 10 | 12 | 14) {
  if (M.byteLength !== 16) {
    throw new KitError(`Message length must be 16 bytes`)
  }
  const S = M.slice(0)

  const AddRoundKey = (W: Uint8Array) => {
    for (let i = 0; i < S.byteLength; i++) {
      S[i] ^= W[i]
    }
  }
  const InvSubBytes = () => {
    for (let i = 0; i < S.byteLength; i++) {
      S[i] = InvSBox[S[i]]
    }
  }
  const InvShiftRows = () => {
    const S13 = S[13]
    S[13] = S[9]
    S[9] = S[5]
    S[5] = S[1]
    S[1] = S13

    const S2 = S[2]
    const S6 = S[6]
    S[2] = S[10]
    S[6] = S[14]
    S[10] = S2
    S[14] = S6

    const S3 = S[3]
    S[3] = S[7]
    S[7] = S[11]
    S[11] = S[15]
    S[15] = S3
  }
  const InvMixColumn = () => {
    for (let i = 0; i < 4; i++) {
      const s0 = S[(i << 2)]
      const s1 = S[(i << 2) + 1]
      const s2 = S[(i << 2) + 2]
      const s3 = S[(i << 2) + 3]

      const t0 = GFMultiply(s0, 0x0E) ^ GFMultiply(s1, 0x0B) ^ GFMultiply(s2, 0x0D) ^ GFMultiply(s3, 0x09)
      const t1 = GFMultiply(s0, 0x09) ^ GFMultiply(s1, 0x0E) ^ GFMultiply(s2, 0x0B) ^ GFMultiply(s3, 0x0D)
      const t2 = GFMultiply(s0, 0x0D) ^ GFMultiply(s1, 0x09) ^ GFMultiply(s2, 0x0E) ^ GFMultiply(s3, 0x0B)
      const t3 = GFMultiply(s0, 0x0B) ^ GFMultiply(s1, 0x0D) ^ GFMultiply(s2, 0x09) ^ GFMultiply(s3, 0x0E)

      S[(i << 2)] = t0
      S[(i << 2) + 1] = t1
      S[(i << 2) + 2] = t2
      S[(i << 2) + 3] = t3
    }
  }

  AddRoundKey(W.subarray(W.length - 16, W.length))
  for (let i = Nr - 1; i > 0; i--) {
    InvShiftRows()
    InvSubBytes()
    AddRoundKey(W.subarray(i << 4, (i + 1) << 4))
    InvMixColumn()
  }
  InvShiftRows()
  InvSubBytes()
  AddRoundKey(W.subarray(0, 16))

  return new Uint8Array(S.buffer)
}

function _aes(K: Uint8Array, b: 128 | 192 | 256) {
  if (K.byteLength !== b >> 3) {
    throw new KitError(`Key length must be ${b >> 3} bytes`)
  }
  const Nr = b === 128 ? 10 : (b === 192 ? 12 : 14)
  const W = KeyExpansion(K, Nr)

  return {
    encrypt: (M: Uint8Array) => Cipher(M, W, Nr),
    decrypt: (C: Uint8Array) => InvCipher(C, W, Nr),
  }
}

/**
 * @description
 * Advanced Encryption Standard (AES) block cipher algorithm.
 *
 * 高级加密标准 (AES) 分组密码算法.
 *
 * @param {128 | 192 | 256} b - Key length (bits).
 */
export function aes(b: 128 | 192 | 256) {
  return createCipher(
    (K: Uint8Array) => _aes(K, b),
    {
      ALGORITHM: `AES-${b}`,
      BLOCK_SIZE: 16,
      KEY_SIZE: b >> 3,
    },
  )
}
